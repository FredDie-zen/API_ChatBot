<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FredDie Zen - Chat (Upgraded)</title>
<style>
  :root {
    --bg-color: #ffffff;
    --text-color: #000000;
    --sidebar-bg: #f3f3f3;
    --sidebar-border: #d0d0d0;
    --input-bg: #eeeeee;
    --user-msg-bg: #d4f5d4;
    --bot-msg-bg: #e2e8f0;
    --accent-color: #1f6feb;
  }
  body.dark {
    --bg-color: #0d1117;
    --text-color: #c9d1d9;
    --sidebar-bg: #161b22;
    --sidebar-border: #30363d;
    --input-bg: #21262d;
    --user-msg-bg: #238636;
    --bot-msg-bg: #343942;
    --accent-color: #58a6ff;
  }
  body {
    margin: 0;
    display: flex;
    font-family: 'Segoe UI', sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    height: 100vh;
    overflow: hidden;
    transition: background 0.3s ease;
  }
  .sidebar {
    width: 240px;
    background-color: var(--sidebar-bg);
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--sidebar-border);
  }
  .sidebar h2 {
    margin-bottom: 10px;
    font-size: 18px;
  }
  .sidebar button {
    background-color: var(--accent-color);
    border: none;
    padding: 10px;
    color: white;
    font-weight: bold;
    width: 100%;
    margin-bottom: 10px;
    cursor: pointer;
    border-radius: 6px;
  }
  .chat-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .chat-list li {
    background: transparent;
    padding: 8px 10px;
    border-radius: 5px;
    margin-bottom: 5px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.2s;
    color: var(--text-color);
  }
  .chat-list li.selected {
    background-color: var(--accent-color);
    color: #fff;
  }
  .chat-list li:hover:not(.selected) {
    background: rgba(31, 111, 235, 0.1);
  }
  .chat-list li span.title {
    flex-grow: 1;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    padding-right: 5px;
  }
  .chat-list li button {
    background: transparent;
    border: none;
    color: var(--text-color);
    cursor: pointer;
    margin-left: 5px;
    font-size: 14px;
  }
  .main {
    flex: 1;
    display: flex;
    flex-direction: column;
    background-color: var(--bg-color);
    position: relative;
  }
  .chat-box {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .message {
    max-width: 80%;
    padding: 12px 16px;
    border-radius: 12px;
    word-wrap: break-word;
    white-space: pre-wrap;
    display: flex;
    align-items: center;
    gap: 10px;
    position: relative;
  }
  .user {
    align-self: flex-end;
    background-color: var(--user-msg-bg);
    color: #000;
    flex-direction: row-reverse;
  }
  .bot {
    align-self: flex-start;
    background-color: var(--bot-msg-bg);
    color: #000;
    flex-direction: row;
  }
  .avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    user-select: none;
  }
  .input-box {
    display: flex;
    padding: 10px 20px;
    background-color: var(--input-bg);
    gap: 10px;
    align-items: center;
  }
  .input-box input[type="text"] {
    flex: 1;
    padding: 12px;
    border-radius: 6px;
    border: none;
    background-color: #ffffff;
    color: #000;
    font-size: 16px;
  }
  .input-box button, .input-box label {
    padding: 12px 16px;
    background-color: var(--accent-color);
    color: #fff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    user-select: none;
  }
  #fileInput {
    display: none;
  }
  .typing-cursor {
    border-right: 2px solid #000;
    animation: blink 0.7s infinite;
  }
  @keyframes blink {
    0%, 100% { border-color: transparent; }
    50% { border-color: black; }
  }
  /* Scroll to top button */
  #scrollTopBtn {
    display: none;
    position: fixed;
    bottom: 80px;
    right: 20px;
    padding: 10px 14px;
    border: none;
    border-radius: 5px;
    background: var(--accent-color);
    color: white;
    cursor: pointer;
    z-index: 10;
  }
  /* Timestamp */
  .timestamp {
    font-size: 10px;
    color: #555;
    margin-left: auto;
    user-select: none;
  }
</style>
<!-- jsPDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <div class="sidebar">
    <h2>FredDie ChatBot üôá‚Äç‚ôÇÔ∏è</h2>
    <button class="new-chat-btn" onclick="startNewChat()">+ New Chat</button>
    <button onclick="toggleDarkMode()" title="Toggle Dark Mode">üåô/‚òÄÔ∏è</button>
    <ul id="chatList" class="chat-list"></ul>
  </div>
  <div class="main">
    <div class="chat-box" id="chatBox"></div>
    <button id="scrollTopBtn" title="Scroll to Top">‚¨ÜÔ∏è Top</button>
    <div class="input-box">
      <input id="userInput" type="text" placeholder="Type your message..." autocomplete="off" />
      <label for="fileInput" title="Upload File" aria-label="Upload File">üìé</label>
      <input type="file" id="fileInput" />
      <button onclick="startVoice()" title="Voice Input">üé§</button>
      <button onclick="sendMessage()">Send</button>
      <button onclick="clearCurrentChat()" title="Clear Chat">üóë Clear</button>
      <button onclick="copyLastResponse()" title="Copy last bot message">üìã</button>
      <button onclick="exportCurrentChatTXT()" title="Export chat as TXT">üíæ TXT</button>
      <button onclick="exportCurrentChatPDF()" title="Export chat as PDF">üìÑ PDF</button>
    </div>
  </div>

<script>
  const chatBox = document.getElementById("chatBox");
  const userInput = document.getElementById("userInput");
  const chatList = document.getElementById("chatList");
  const fileInput = document.getElementById("fileInput");
  const scrollTopBtn = document.getElementById("scrollTopBtn");

  let savedChats = {};
  let chatHistory = [];
  let currentChatTitle = null;

  // Append message with avatar, timestamp, and typing animation for bot
  function appendMessage(text, isUser) {
    const msg = document.createElement("div");
    msg.className = "message " + (isUser ? "user" : "bot");

    // Avatar
    const avatar = document.createElement("img");
    avatar.className = "avatar";
    avatar.src = isUser
      ? "https://i.pravatar.cc/32?u=user" // user avatar
      : "https://cdn-icons-png.flaticon.com/512/4712/4712027.png"; // bot avatar (robot icon)
    avatar.alt = isUser ? "User avatar" : "Bot avatar";

    // Text container (for typing effect on bot messages)
    const textDiv = document.createElement("div");

    if (!isUser) {
      // typing animation for bot message
      let i = 0;
      const typingInterval = setInterval(() => {
        textDiv.textContent = text.substring(0, i++) + (i <= text.length ? "|" : "");
        if (i > text.length) {
          clearInterval(typingInterval);
          textDiv.textContent = text;
        }
        chatBox.scrollTop = chatBox.scrollHeight;
      }, 20);
    } else {
      textDiv.textContent = text;
    }

    // Timestamp
    const timeSpan = document.createElement("span");
    timeSpan.className = "timestamp";
    const now = new Date();
    timeSpan.textContent = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    msg.appendChild(avatar);
    msg.appendChild(textDiv);
    msg.appendChild(timeSpan);
    chatBox.appendChild(msg);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  function showTyping() {
    const typing = document.createElement("div");
    typing.id = "typing";
    typing.className = "message bot typing";
    typing.textContent = "Typing...";
    chatBox.appendChild(typing);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  function removeTyping() {
    const typing = document.getElementById("typing");
    if (typing) typing.remove();
  }

  async function sendMessage() {
    const text = userInput.value.trim();
    if (!text) return;
    appendMessage(text, true);
    userInput.value = "";
    chatHistory.push({ role: "user", content: text });
    saveChatsToLocalStorage();
    showTyping();

    try {
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": "Bearer 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",
          "HTTP-Referer": "https://www.sitename.com",
          "X-Title": "SiteName",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "openai/gpt-3.5-turbo",
          messages: chatHistory
        })
      });

      const data = await response.json();
      removeTyping();

      const reply = data.choices?.[0]?.message?.content || "No response.";
      appendMessage(reply, false);
      chatHistory.push({ role: "assistant", content: reply });
      saveChatsToLocalStorage();

    } catch (error) {
      removeTyping();
      appendMessage("Error: " + error.message, false);
    }
  }

  // Voice input (Chrome only)
  function startVoice() {
    if (!('webkitSpeechRecognition' in window)) {
      alert("Your browser does not support voice recognition.");
      return;
    }
    const recognition = new webkitSpeechRecognition();
    recognition.lang = "en-US";
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    recognition.start();

    recognition.onresult = function (event) {
      const transcript = event.results[0][0].transcript;
      appendMessage(transcript, true);
      chatHistory.push({ role: "user", content: transcript });
      saveChatsToLocalStorage();
      sendMessageAfterVoice(transcript);
    };

    recognition.onerror = function (event) {
      alert("Voice error: " + event.error);
    };
  }

  async function sendMessageAfterVoice(text) {
    showTyping();
    try {
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": "Bearer <please enter API key>",
          "HTTP-Referer": "https://www.sitename.com",
          "X-Title": "SiteName",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "openai/gpt-3.5-turbo",
          messages: [...chatHistory, { role: "user", content: text }]
        })
      });

      const data = await response.json();
      removeTyping();

      const reply = data.choices?.[0]?.message?.content || "No response.";
      appendMessage(reply, false);
      chatHistory.push({ role: "assistant", content: reply });
      saveChatsToLocalStorage();

    } catch (error) {
      removeTyping();
      appendMessage("Error: " + error.message, false);
    }
  }

  // File upload handler
  fileInput.addEventListener("change", () => {
    const file = fileInput.files[0];
    if (file) {
      appendMessage(`üìÅ Uploaded file: ${file.name}`, true);
      chatHistory.push({ role: "user", content: `üìÅ Uploaded file: ${file.name}` });
      saveChatsToLocalStorage();

      // Bot response simulated
      setTimeout(() => {
        appendMessage(`Received your file: ${file.name} (${Math.round(file.size / 1024)} KB)`, false);
        chatHistory.push({ role: "assistant", content: `Received your file: ${file.name} (${Math.round(file.size / 1024)} KB)` });
        saveChatsToLocalStorage();
      }, 700);
    }
  });

  // Start new chat
  function startNewChat() {
    const title = prompt("Enter chat title:");
    if (!title) return;

    if (currentChatTitle) savedChats[currentChatTitle] = [...chatHistory];
    currentChatTitle = title;
    chatHistory = savedChats[title] || [];
    chatBox.innerHTML = "";
    chatHistory.forEach(msg => appendMessage(msg.content, msg.role === "user"));

    if (!savedChats[title]) {
      savedChats[title] = [...chatHistory];
      addChatListItem(title);
    }

    setSelectedChat(title);
    saveChatsToLocalStorage();
    focusInput();
  }

  // Add chat list item
  function addChatListItem(title) {
    const item = document.createElement("li");
    item.classList.add("chat-item");

    const titleSpan = document.createElement("span");
    titleSpan.className = "title";
    titleSpan.textContent = title;

    item.onclick = () => {
      if (currentChatTitle) savedChats[currentChatTitle] = [...chatHistory];
      currentChatTitle = title;
      chatHistory = savedChats[title] || [];
      chatBox.innerHTML = "";
      chatHistory.forEach(msg => appendMessage(msg.content, msg.role === "user"));
      setSelectedChat(title);
      saveChatsToLocalStorage();
      focusInput();
    };

    const delBtn = document.createElement("button");
    delBtn.title = "Delete chat";
    delBtn.textContent = "üóë";
    delBtn.onclick = e => {
      e.stopPropagation();
      if (confirm(`Delete chat "${title}"? This cannot be undone.`)) {
        delete savedChats[title];
        if (currentChatTitle === title) {
          chatHistory = [];
          chatBox.innerHTML = "";
          currentChatTitle = null;
        }
        item.remove();
        saveChatsToLocalStorage();
      }
    };

    const renBtn = document.createElement("button");
    renBtn.title = "Rename chat";
    renBtn.textContent = "‚úèÔ∏è";
    renBtn.onclick = e => {
      e.stopPropagation();
      const newTitle = prompt("Enter new chat title:", title);
      if (newTitle && newTitle !== title) {
        if (savedChats[newTitle]) {
          alert("Chat with this title already exists!");
          return;
        }
        savedChats[newTitle] = savedChats[title];
        delete savedChats[title];
        titleSpan.textContent = newTitle;
        if (currentChatTitle === title) currentChatTitle = newTitle;
        saveChatsToLocalStorage();
      }
    };

    const expBtn = document.createElement("button");
    expBtn.title = "Export chat as TXT";
    expBtn.textContent = "üíæ";
    expBtn.onclick = e => {
      e.stopPropagation();
      exportChatTXT(title);
    };

    const expPdfBtn = document.createElement("button");
    expPdfBtn.title = "Export chat as PDF";
    expPdfBtn.textContent = "üìÑ";
    expPdfBtn.onclick = e => {
      e.stopPropagation();
      exportChatPDF(title);
    };

    item.appendChild(titleSpan);
    item.appendChild(delBtn);
    item.appendChild(renBtn);
    item.appendChild(expBtn);
    item.appendChild(expPdfBtn);
    chatList.appendChild(item);
  }

  function setSelectedChat(title) {
    Array.from(chatList.children).forEach(li => {
      li.classList.toggle("selected", li.querySelector(".title").textContent === title);
    });
  }

  // Export current chat TXT
  function exportCurrentChatTXT() {
    if (!currentChatTitle) return alert("No chat selected!");
    exportChatTXT(currentChatTitle);
  }
  // Export chat as TXT helper
  function exportChatTXT(title) {
    const messages = savedChats[title];
    if (!messages) return alert("No chat history found!");

    const text = messages.map(m => (m.role === "user" ? "You: " : "Bot: ") + m.content).join("\n\n");
    const blob = new Blob([text], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${title}.txt`;
    link.click();
  }

  // Export current chat PDF
  function exportCurrentChatPDF() {
    if (!currentChatTitle) return alert("No chat selected!");
    exportChatPDF(currentChatTitle);
  }
  // Export chat as PDF helper using jsPDF
  async function exportChatPDF(title) {
    const { jsPDF } = window.jspdf;
    const messages = savedChats[title];
    if (!messages) return alert("No chat history found!");

    const doc = new jsPDF();
    let y = 10;
    messages.forEach(m => {
      const line = (m.role === "user" ? "You: " : "Bot: ") + m.content;
      const splitText = doc.splitTextToSize(line, 180);
      doc.text(splitText, 10, y);
      y += splitText.length * 10;
      if (y > 280) {
        doc.addPage();
        y = 10;
      }
    });
    doc.save(`${title}.pdf`);
  }

  // Save chats to localStorage
  function saveChatsToLocalStorage() {
    localStorage.setItem("savedChats", JSON.stringify(savedChats));
    localStorage.setItem("currentChatTitle", currentChatTitle);
  }

  // Load chats from localStorage
  function loadChatsFromLocalStorage() {
    const saved = localStorage.getItem("savedChats");
    if (saved) {
      savedChats = JSON.parse(saved);
      Object.keys(savedChats).forEach(title => addChatListItem(title));
    }
    const current = localStorage.getItem("currentChatTitle");
    if (current && savedChats[current]) {
      currentChatTitle = current;
      chatHistory = savedChats[current];
      chatBox.innerHTML = "";
      chatHistory.forEach(msg => appendMessage(msg.content, msg.role === "user"));
      setSelectedChat(current);
    }
  }

  // Clear current chat messages but keep chat
  function clearCurrentChat() {
    if (!currentChatTitle) return alert("No chat selected!");
    if (confirm("Clear all messages in this chat?")) {
      chatHistory = [];
      savedChats[currentChatTitle] = [];
      chatBox.innerHTML = "";
      saveChatsToLocalStorage();
    }
  }

  // Copy last bot response
  function copyLastResponse() {
    if (!chatHistory.length) return alert("No messages to copy!");
    for (let i = chatHistory.length - 1; i >= 0; i--) {
      if (chatHistory[i].role === "assistant") {
        navigator.clipboard.writeText(chatHistory[i].content)
          .then(() => alert("Last bot response copied!"))
          .catch(() => alert("Failed to copy!"));
        return;
      }
    }
    alert("No bot response found!");
  }

  // Scroll to top button logic
  chatBox.addEventListener("scroll", () => {
    if (chatBox.scrollTop > 300) scrollTopBtn.style.display = "block";
    else scrollTopBtn.style.display = "none";
  });
  scrollTopBtn.onclick = () => {
    chatBox.scrollTo({ top: 0, behavior: 'smooth' });
  };

  // Dark mode toggle
  function toggleDarkMode() {
    document.body.classList.toggle("dark");
    localStorage.setItem("darkMode", document.body.classList.contains("dark"));
  }

    // Replace the old keyboard listener with this one:
    userInput.addEventListener("keydown", e => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault(); // avoid newline
          sendMessage(); // call your send message function
        }
      });

  // Auto focus input
  function focusInput() {
    userInput.focus();
  }

  // Load on window load
  window.onload = () => {
    if (localStorage.getItem("darkMode") === "true") {
      document.body.classList.add("dark");
    }
    loadChatsFromLocalStorage();
    focusInput();
  };
</script>
</body>
</html>
